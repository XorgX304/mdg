import pandas as pd
import os
from flask import Flask, request, render_template
from collections import OrderedDict
from data_generation.awk_data_generator import AWKDataGenerator
from data_generation.data_generator import DataGenerator


# Constants
AMP = '&'
EQ = '='
CSV = '.csv'
EOL = '\n'
COMMA = ','
DELIMITER = 'delimiter'
UTF = 'utf-8'

# Option arguments for SQL/XML/CSV
# Using camel case just to match front end arguments
FILE_TYPE_OPTIONS = ('tableName', 'createTable', 'xmlNode', 'delimiter', 'sqlExtension')

# Data types generated using AWK
AWK_GENERATED = ('auto-increment', 'random-float', 'random-int', 'timestamp', 'zipcode', 'phone', 'cc-number',
                 'cvv', 'balance', 'cc-exp', 'rgb')

# Instances
app = Flask(__name__, static_url_path='')  # Set static folder path
awk = AWKDataGenerator()
dg = DataGenerator()

delimiter_chars = {
    "comma": ",",
    "caret": "^",
    "semi": ";",
    "tab": "\t",
    "pipe": "|"
}


# Index
@app.route('/')
def index():
    return app.send_static_file('index.html')


# Generate POST handler
@app.route('/generate', methods=['POST'])
def generate():
    """Parse request parameters, generate files & upload file. Respond with download link"""
    # Decode request literal to utf8
    request_literal = request.get_data().decode(UTF)
    # Create on OrderedDict from the request literal
    post_data = parse_post_data(request_literal)
    # Create headers list & and file type special options dictionary
    headers = list(post_data.keys())
    awk_generated = list(header for header in headers if post_data.get(header) in AWK_GENERATED)
    file_type_args = {}
    for option in FILE_TYPE_OPTIONS:
        if option in headers:
            file_type_args[option] = post_data.get(option)
            headers.remove(option)
    # Extract file name, type and number of rows
    filename = post_data.get(headers.pop()) + CSV
    num_rows = post_data.get(headers.pop())
    file_type = post_data.get(headers.pop())
    # Create an empty file with headers
    with open(filename, 'w') as file:
        file.write(COMMA.join(headers) + EOL)
    # Write file
    write_awk_columns(headers, awk_generated, post_data, num_rows, filename, file_type_args)
    return ''


def parse_post_data(request_data):
    """
    Creates an ordered dict containing the post request files.
    Uses literal request files (not parsed) due to parsed files's order being mixed which affects
    the user's wanted order
    """
    # Split literal request files
    split_data = [element.split(EQ) for element in request_data.split(AMP)]
    post_data = OrderedDict()
    for group in split_data:
        post_data[group[0]] = group[1]
    return post_data


def write_awk_columns(headers, awk_generated, post_data, num_rows, filename, file_type_args):
    os.system(awk.create_awk_statement(post_data, headers, num_rows, filename))
    # If all columns are generated by AWK, writing to file is done
    if all([i in awk_generated for i in headers]):
        pass
    # Else call write_columns func with python_generated column set
    else:
        print('never here')
        python_generated = set(headers) - set(awk_generated)
        # Get delimiter or set default one
        delimiter = delimiter_chars.get(file_type_args.get(DELIMITER), COMMA)
        write_pandas_columns(filename, post_data, python_generated, delimiter)
    return


def write_pandas_columns(filename, post_data, python_generated, delimiter):
    """Write non-AWK column files using Pandas"""
    df = pd.read_csv(filename, sep=COMMA)
    for header in python_generated:
        try:
            # Get corresponding command for files type and apply to the entire column
            df[header] = df[header].apply(lambda x: dg.commands.get(post_data.get(header))())
        except TypeError as err:
            print(err)
            pass  # TODO log
    # Write the csv with new values and delimiter
    df.to_csv(filename, sep=delimiter, index=False)
    return


# Errors #
@app.errorhandler(404)
def not_found():
    return app.send_static_file('error.html'), 404

