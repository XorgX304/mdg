import os
import json
from collections import OrderedDict
from time import time
import pandas as pd
from flask import Flask, request
from backend.data_generation.awk_data_generator import AWKDataGenerator
from backend.data_generation.data_generator import DataGenerator


# Module level constants
AMP = '&'
EQ = '='
CSV = '.csv'
QUOTES = '"'
EOL = '\n'
COMMA = ','
DELIMITER = 'delimiter'
UTF = 'utf-8'
MAX_ROWS = 250000
SEMI_COLON = ';'
with open('config.json', 'r') as json_config:
    CONFIG = json.loads(json_config.read())

# Instances
app = Flask(__name__, static_url_path='')  # Set static folder path
awk = AWKDataGenerator()
data_generator = DataGenerator()


# Index
@app.route('/')
def index():
    return app.send_static_file('index.html')


# Generate POST handler
@app.route('/generate', methods=['POST'])
def generate():
    """Parse request parameters, generate & upload file. Respond with download link"""
    start = time()
    # Decode request literal to utf8
    request_literal = request.get_data().decode(UTF)
    # Create on OrderedDict from the request literal
    post_data = parse_post_data(request_literal)
    # Create headers list, awk generated list & and special options dictionary
    headers = list(post_data.keys())
    awk_generated = list(
        header for header in headers if post_data.get(header) in CONFIG['options']['awk_generated'])
    # Extract specific data types options
    options_dict = {
        key: post_data.get(key) for key in headers for option in CONFIG['options']['data_type_options'] if option in key}
    # Extract options regarding file type
    for option in CONFIG['options']['file_type_options']:
        if option in headers:
            options_dict[option] = post_data.get(option)
    headers = [header for header in headers if header not in options_dict.keys()]
    # Now headers contain all column names and options_dict contains all special file/data key:value pairs

    # Extract file name, type and number of rows
    filename = post_data.get(headers.pop()) + CSV
    num_rows = post_data.get(headers.pop())
    file_type = post_data.get(headers.pop())
    if int(num_rows) > MAX_ROWS or len(headers) > 10:
        return "Illegel request", 400
    # Create an empty file with headers
    with open(filename, 'w') as file:
        file.write(COMMA.join(headers) + EOL)
    # Write file
    write_awk_generated(headers, awk_generated, post_data, num_rows, filename, options_dict)
    # Check if file needs to be converted from CSV
    if not is_csv(file_type):
        filename = file_conversion(file_type, filename, options_dict, headers, post_data)
    print(time() - start)
    return filename


def parse_post_data(request_data):
    """
    Creates an ordered dict containing the POST request files.
    Uses literal request files (not parsed) due to parsed files's order being mixed which affects
    the user's wanted order
    """
    # Split literal request files
    split_data = [element.split(EQ) for element in request_data.split(AMP)]
    post_data = OrderedDict()
    for group in split_data:
        post_data[group[0]] = group[1]
    return post_data


def write_awk_generated(headers, awk_generated, post_data, num_rows, filename, options):
    """
    Write all AWK related columns. If all columns are generated by AWK, return, else
    create a set of Python generated headers and call write_python_generated function.
    """
    os.system(awk.create_awk_statement(post_data, headers, num_rows, filename, options))
    # If all columns are generated by AWK, writing to file is done
    if all([column in awk_generated for column in headers]):
        pass
    # Else call write_python_generated func with python_generated column set
    else:
        python_generated = set(headers) - set(awk_generated)
        # Get delimiter from options or set default one
        delimiter = CONFIG['delimiter_chars'].get(options.get(DELIMITER), COMMA)
        write_python_generated(filename, post_data, python_generated, delimiter, options)
    return


def write_python_generated(filename, post_data, python_generated, delimiter, options):
    """Write non-AWK column files using Pandas"""
    df = pd.read_csv(filename, sep=COMMA)
    for header in python_generated:
        try:
            callback = data_generator.commands.get(post_data.get(header))
            # If callback data type is generated from a list, return a random element
            # Else call it's corresponding function
            df[header] = df[header].apply(
                    lambda x: data_generator.rand_element(callback) if isinstance(callback, list)
                    else callback(header, options))
        except TypeError as err:
            print(err)
    # Write the csv with new values and delimiter
    df.to_csv(filename, sep=delimiter, index=False)
    return


def is_csv(file_type):
    """Check if file type is CSV"""
    return file_type == CSV


def file_conversion(file_type, filename, options, headers, post_data):
    """Check file type and call appropriate conversion function"""
    if file_type == '.json':
        filename = convert_to_json(filename)
    elif file_type == '.xml':
        filename = convert_to_xml(filename, options)
    elif file_type == '.sql':
        filename = convert_to_sql(filename, options, headers, post_data)
    return filename


def convert_to_xml(filename, options):
    """Call c2x library to convert CSV to XML"""
    root_node = options.get(CONFIG['options']["file_type_options"][4])
    record_node = options.get(CONFIG['options']["file_type_options"][5])
    xml_file = filename.split('.')[0] + '.xml'
    os.system(CONFIG['conversion']['xml'].format(filename, root_node, record_node))
    return xml_file


def convert_to_json(filename):
    """Call csv2json library to convert CSV to JSON"""
    json_file = filename.split('.')[0] + '.json'
    os.system(CONFIG['conversion']['json'].format(filename, json_file))
    return json_file


def convert_to_sql(filename, options, headers, post_data):
    """
    Convert CSV file to SQL.
    Extract table name and create table args from options, write SQL insert statements formatted with values
    from each file's row using pandas itertuples function.
    """
    # Set wanted sql file extension
    sql_file = filename.split('.')[0] + options.get(CONFIG['options']['file_type_options'][3])
    # Set wanted table name and format SQL insert string with table name
    table_name = options.get(CONFIG['options']['file_type_options'][0])  # Get table name from options
    sql_insert = CONFIG['sql']['insert'].format(table_name)
    # Load previously created CSV with pandas
    df = pd.read_csv(filename, sep=COMMA, index_col=0)
    with open(sql_file, 'w') as file:
        # Test if create table was checked by user
        # Parameter comes as string representation from request hence the `== true` check
        if options.get(CONFIG['options']['file_type_options'][1]) == 'true':
            # Write create table statement
            sql_table_creation_string = sql_create_table(headers, post_data)
            file.write(CONFIG['sql']['create'].format(table_name, sql_table_creation_string))
        for row in df.itertuples():
            file.write(
                # Wrap value with double quotes if its VARCHAR or DATE
                sql_insert % (COMMA.join([QUOTES + x + QUOTES if isinstance(x, str) else str(x) for x in list(row)])))
    return sql_file


def sql_create_table(headers, post_data):
    """Return create table statement with SQL data types"""
    table_creation = []
    for header in headers:
        if post_data.get(header) in CONFIG['sql']['decimal_types']:
            table_creation.append(header + CONFIG['sql']['decimal'])
        elif post_data.get(header) in CONFIG['sql']['int_types']:
            table_creation.append(header + CONFIG['sql']['int'])
        elif post_data.get(header) in CONFIG['sql']['date']:
            table_creation.append(header + CONFIG['sql']['date'])
        else:
            table_creation.append(header + CONFIG['sql']['varchar'])
    return (COMMA + EOL).join(table_creation)


# 404 #
@app.errorhandler(404)
def not_found():
    return app.send_static_file('error.html'), 404
